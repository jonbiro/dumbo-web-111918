
/* global */
// garbage = "fire"

// function potato() {
//   trash = "fire"
// }

// potato()

// console.log(garbage)
// console.log(trash)

/* var */

// var foo = "bar"

// var foo = "yo"



// function potato() {
//   var foo = "blat"
//   console.log(foo)
// }


// potato();

// console.log(foo)



const foo = "bar"
// let foo = "bar"

foo = "baz"



if (true){
  let banana =  "potato" 
  console.log(banana)
}

for (let i = 0; i < 100; i++) {
  console.log(i);
}

console.log(i);

// bsdfkjhsdf();

// consoxle.log(banana)


// biggest difference between 






// var foo = "bar"

// if (foo = "potato") {
//   console.log("FRIEEEESSSS")
// }

// if (foo == true) {
//   console.log("POTATO PANCAKES")
// }

// var five = false

// if (0 == "0") {
//   console.log("fiiiiiiive");
// }

// if (five === "false") {
//   console.log("heeeeeyyyyyyyyy")
// }


// if (foo === true) {
//   console.log("Vodka!")
// }


// What's the difference between == and truthy/falsy
// In line 9 if you change true to potato without quotes will it log
// What's the best practice when it comes to == and ===
// js(===) === ruby(==) ???????



//primitive
//string, number, undefined, null, booleans, symbols?

//non-primitive
//objects (arrays, functions, { foo: "bar"} )


// var numInAnObject = {
//   number: 5
// }

// function increment(whatever) {
//   whatever.number++
// }

// function addSomeEmojis(whatever) {
//   whatever.emojis = ["游꼴", "游꼴", "游꼴", "游꼴"]
// }


// increment(numInAnObject)
// increment(numInAnObject)
// increment(numInAnObject)
// increment(numInAnObject)
// increment(numInAnObject)
// increment(numInAnObject)
// increment(numInAnObject)

// addSomeEmojis(numInAnObject)

// console.log(numInAnObject)

// Why is it that whatever happens in the function 
// stays in the function? Because of pass-by-value?

// Go further into object mutation via passing by reference?



// var num = 5

// function increment() {
//   num++
// }

// increment()

// console.log(num)



